/**
 * Emulator internals. Contains the API as well as the emulator UI.
 *
 * The declarations of the interfaces are found in emulator.api.ts
 *
 * This file contains the implementation of the emulator. This is split into
 * several classes:
 *
 *  - The emulator class. The public methods on this define the public interface
 *  for an application running inside the emulator.
 *
 *  - The emulator_ui class. This is the internal workings of the emulator's
 *  "operating system" user interface, and is responsible for loading applications
 *  - The emulator_storage class, which is how the application can access
 *  persistant storage on the smart watch.
 *
 */
/// <reference path="emulator.api.ts"/>
/**
 * Get the width of the context
 */
CanvasRenderingContext2D.prototype.width = function () {
    return this.canvas.width;
};
/**
 * Get the height of the context
 */
CanvasRenderingContext2D.prototype.height = function () {
    return this.canvas.height;
};
/**
 * Clear the context
 */
CanvasRenderingContext2D.prototype.clear = function () {
    this.clearRect(0, 0, this.canvas.width, this.canvas.height);
};
/** Local Storage Class. Stores an object by converting it to a JSON string
 * and storing it in the browser's local storage. */
var emulator_storage = (function () {
    function emulator_storage() {
    }
    /** Update the table displaying the local storage so the user can see the contents */
    emulator_storage.update_table = function () {
        var table = document.getElementById("data_table");
        if (table) {
            /* Access the HTML table.*/
            /* Retrieve from localStorage and output in HTML table. */
            var data = "<tr><th>Key</th><th>Value</th><th></th></tr>";
            for (var key in localStorage) {
                data += "<tr><td>" + key + "</td><td>" + localStorage[key] + "</td>" +
                    "<td><a onclick=\"new emulator_storage().remove_object('" + key +
                    "')\"" + ">Delete</a></td></tr>";
            }
            table.innerHTML = data;
        }
    };
    /** Remove the object corresponding to the given key */
    emulator_storage.prototype.remove_object = function (key) {
        localStorage.removeItem(key);
        emulator_storage.update_table();
    };
    /** Add/Set the given value/object to be stored at the given key. */
    emulator_storage.prototype.set_object = function (key, value) {
        localStorage.setItem(key, JSON.stringify(value));
        emulator_storage.update_table();
    };
    /** Retrieve the object in local storage corresponding to the given key. */
    emulator_storage.prototype.get_object = function (key) {
        var value = localStorage.getItem(key);
        return value && JSON.parse(value);
    };
    return emulator_storage;
}());
/** Container Class for application information inside the emulator. This is
 * generated by emulator.register_application, where the purposes are defined.
 */
var registered_application = (function () {
    function registered_application(name, start_callback, render_callback, home_callback) {
        this.name = name;
        this.start_callback = start_callback;
        this.render_callback = render_callback;
        this.home_callback = home_callback;
    }
    return registered_application;
}());
/** Emulator user interface class. */
var emulator_ui = (function () {
    /** Construct this emulator ui */
    function emulator_ui() {
        this.current_app = 0;
        this.app_list = [];
    }
    /** Connect UI to a canvas for display */
    emulator_ui.prototype.set_display = function (display) {
        this.canvas = display;
    };
    /** Initialize the UI */
    emulator_ui.prototype.init = function () {
        var _this = this;
        this.gest_call_ref = os.add_gesture_handler(function (e, x, y) { return _this.gest_handle(e, x, y); }); // This anon function creates a closure so that `this` is a sensible value
        this.draw();
    };
    /** Draw the application name of the current application to screen */
    emulator_ui.prototype.draw = function () {
        var ctx = this.canvas.getContext("2d");
        ctx.clear();
        ctx.fillStyle = "#111111";
        ctx.fillRect(0, 0, ctx.width(), ctx.height());
        ctx.fillStyle = "#222222";
        var top_bar_height = 40;
        ctx.fillRect(0, 0, ctx.width(), top_bar_height);
        ctx.fillStyle = "#CCCCCC";
        var options = {
            weekday: "long", year: "numeric", month: "short",
            day: "numeric", hour: "2-digit", minute: "2-digit"
        };
        var time_display = os.get_time().toLocaleTimeString("en-GB", options);
        ctx.textAlign = "center";
        ctx.font = "10px sans-serif";
        ctx.fillText(time_display, this.canvas.width / 2, top_bar_height / 2);
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#EEEEEE";
        if (this.app_list[this.current_app]) {
            ctx.fillText(this.app_list[this.current_app].name, this.canvas.width / 2, this.canvas.height / 2);
        }
        else {
            ctx.fillText("No Application", this.canvas.width / 2, this.canvas.height / 2);
        }
    };
    /** Change the current application on swipe, and call the start callback
     * when tapped.
     */
    emulator_ui.prototype.gest_handle = function (evt, x, y) {
        if (this.app_list.length === 0) {
            return;
        }
        switch (evt) {
            // Go to next app
            case gesture_type.swipeleft:
                this.current_app = (this.current_app + 1) % this.app_list.length;
                this.draw();
                break;
            // Go to previous app
            case gesture_type.swiperight:
                this.current_app--;
                if (this.current_app < 0)
                    this.current_app = this.app_list.length - 1;
                this.draw();
                break;
            // Start current app
            case gesture_type.tap:
                /*  First unregister UI click/swipe handlers */
                os.remove_gesture_handler(this.gest_call_ref);
                /* Call application to start, and then set set it to be rendered. */
                this.app_list[this.current_app].start_callback();
                var unsafe = os; // Remove type checking on the interface to access render_function directly
                unsafe.current_app = this.app_list[this.current_app];
        }
    };
    return emulator_ui;
}());
/*
 * Main emulator API and internal logic.
 */
var emulator = (function () {
    /** Construct the smart watch */
    function emulator() {
        this.gesture_handlers = [];
        this.ui = new emulator_ui();
        this.last_date = this.last_reported_date = new Date();
    }
    /** Initialize and start the smart watch */
    emulator.prototype.init = function (canvas_id) {
        var _this = this;
        this.display = document.getElementById(canvas_id);
        this.ui.set_display(this.display);
        this.ui.init();
        this.gesture_interpreter = new Hammer(this.display, { preset: ["swipe", "tap"] });
        /* This wrapper lets us keep the `this` context correct to this object */
        var call_ref = (function (e) { return _this.internal_gesture_reciever(e); });
        /* Register to all the gestures we want */
        this.gesture_interpreter.on("tap", call_ref);
        this.gesture_interpreter.on("swipeup", call_ref);
        this.gesture_interpreter.on("swipedown", call_ref);
        this.gesture_interpreter.on("swipeleft", call_ref);
        this.gesture_interpreter.on("swiperight", call_ref);
        this.gesture_interpreter.get("swipe").set({ direction: Hammer.DIRECTION_ALL });
        this.current_app = undefined;
        // Make an initial call to set up render callbacks
        this.call_render();
    };
    /**
     * Get a CanvasRenderingContext2D which can draw on the display.
     *
     * This is technically a browser object, but we have specified
     * the interface as part of the emulator, and also added some extensions.
     */
    emulator.prototype.get_graphics_context = function () {
        return this.display.getContext("2d");
    };
    /**
     * This is the function responsible for getting the application
     * to draw a frame, by calling the application's render() function.
     *
     * If the application's render function returns false, then control
     * is given back to the operating system.
     */
    emulator.prototype.call_render = function () {
        var _this = this;
        // Make sure the emulator gets called on the next frame
        requestAnimationFrame(function () { return _this.call_render(); });
        var result;
        // Tell the application to render
        if (this.current_app && this.current_app.render_callback) {
            result = this.current_app.render_callback();
            // If the application says it no longer needs to render
            // i.e. is finished
            if (!result) {
                // Clear render function
                this.current_app = undefined;
                // Start back up UI
                this.ui.init();
            }
        }
        else {
            this.ui.draw();
        }
    };
    /**
     * Get the emulator's persistant storage.
     */
    emulator.prototype.get_local_storage = function () {
        return new emulator_storage();
    };
    /**
     * Add a handler for gestures. Uses the given callback in the context
     * of the given object
     */
    emulator.prototype.add_gesture_handler = function (callback) {
        return this.gesture_handlers.push(callback) - 1;
    };
    /**
     * Remove/unset a handler for gestures. Must provide the returned value
     * from the corresponding call to add_gesture_handler
     *
     * This implementation has a slight memory leak, which is counter-balanced by
     * sparse arrays in ECMAscript.
     */
    emulator.prototype.remove_gesture_handler = function (callback_id) {
        this.gesture_handlers[callback_id] = undefined;
        // TODO: this implementation could cause a memory leak
    };
    /**
     * Recieves gesture events from Hammer Library, then sends them through the
     * array of registered gesture event handlers.
     */
    emulator.prototype.internal_gesture_reciever = function (ev) {
        // Translate mouse to internal coordinates
        var rect = this.display.getBoundingClientRect();
        ev.center.x = ev.center.x - rect.left;
        ev.center.y = ev.center.y - rect.top;
        switch (ev.type) {
            case "tap":
                this.gesture_handlers.forEach(function (item) {
                    if (item)
                        item(gesture_type.tap, ev.center.x, ev.center.y);
                });
                break;
            case "swipeup":
                this.gesture_handlers.forEach(function (item) {
                    if (item)
                        item(gesture_type.swipeup, ev.center.x, ev.center.y);
                });
                break;
            case "swipedown":
                this.gesture_handlers.forEach(function (item) {
                    if (item)
                        item(gesture_type.swipedown, ev.center.x, ev.center.y);
                });
                break;
            case "swipeleft":
                this.gesture_handlers.forEach(function (item) {
                    if (item)
                        item(gesture_type.swipeleft, ev.center.x, ev.center.y);
                });
                break;
            case "swiperight":
                this.gesture_handlers.forEach(function (item) {
                    if (item)
                        item(gesture_type.swiperight, ev.center.x, ev.center.y);
                });
                break;
        }
    };
    /**
     * Gets an image from the specified source for use with the grapics context.
     * @param src The source URL with respect to the root directory of the
     * emulator.
     */
    emulator.prototype.get_image = function (src) {
        var output = new Image();
        output.src = src;
        return output;
    };
    /**
     * Gets the current time in a Date object.
     */
    emulator.prototype.get_time = function () {
        var now = new Date();
        var time_scale = document.getElementById("time_scale");
        if (time_scale) {
            var diff = now.getTime() - this.last_date.getTime();
            diff *= Math.exp(time_scale.value / 10);
            var tmp = new Date();
            tmp.setTime(diff + this.last_reported_date.getTime());
            this.last_date = now;
            return this.last_reported_date = tmp;
        }
        else {
            return now;
        }
    };
    /**
     * Ask the emulator to close the current application.
     */
    emulator.prototype.go_home = function () {
        if (this.current_app && this.current_app.home_callback)
            this.current_app.home_callback();
    };
    /**
     * Register an application with the emulator
     *
     * @param start_callback will be called to initilize the application.
     * @param render_callback will be called to redraw/update the display periodically
     * (each frame). render_callback should return true if the application is to
     * continue, else control will be returned to the operating system. The
     * application can still reciever gesture notifications after returning false,
     * so these must be cleaned up first if this is not desired.
     * @param home_callback is called to request the application to stop,
     * allowing the return to the emulator. The application can choose if this
     * simply hides, or quits, but should not ignore.
     */
    emulator.prototype.register_application = function (name, start_callback, render_callback, home_callback) {
        this.ui.app_list.push(new registered_application(name, start_callback, render_callback, home_callback));
    };
    /**
     * Log a message. This logs to the page element with
     * id="emulator_console", and to the browser console.
     */
    emulator.prototype.log = function (log_text) {
        console.log(log_text);
        var log_div = document.getElementById("emulator_console");
        if (log_div) {
            log_div.innerHTML += "<p>" + log_text + "</p>";
        }
    };
    return emulator;
}());
/** Make global emulator instance */
os = new emulator();
