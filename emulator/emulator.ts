/**
 * Emulator internals. Contains the API as well as the emulator UI.
 * 
 * The declarations of the interfaces are found in emulator.api.ts
 * 
 * This file contains the implementation of the emulator. This is split into
 * several classes:
 *
 *  - The emulator class. The public methods on this define the public interface
 *  for an application running inside the emulator.
 *
 *  - The emulator_ui class. This is the internal workings of the emulator's
 *  "operating system" user interface, and is responsible for loading applications
 *  - The emulator_storage class, which is how the application can access 
 *  persistant storage on the smart watch.
 * 
 */

// Include definitions
/// <reference path="emulator.api.ts"/>

/** Library Declaration */
declare var Hammer: any;



/**
 * Make some extensions to the context API. add clear(), width(), height() so that
 * the application doesn't have to look inside .canvas
 */
 
 interface CanvasRenderingContext2D {
    width: () => number;
    height: () => number;
    clear: () => void;
 }

/**
 * Get the width of the context
 */
CanvasRenderingContext2D.prototype.width = function() {
    return this.canvas.width;
};

/**
 * Get the height of the context
 */
CanvasRenderingContext2D.prototype.height = function() {
    return this.canvas.height;
};

/**
 * Clear the context
 */
CanvasRenderingContext2D.prototype.clear = function() {
    this.clearRect(0, 0, this.canvas.width, this.canvas.height);
};



/** Local Storage Class. Stores an object by converting it to a JSON string
 * and storing it in the browser's local storage. */
class emulator_storage {

    /** Update the table displaying the local storage so the user can see the contents */
    private static update_table () {
        
        let table = document.getElementById("data_table");
        if (table) {
        
            /* Access the HTML table.*/
            /* Retrieve from localStorage and output in HTML table. */

            let data: string = "<tr><th>Key</th><th>Value</th><th></th></tr>";

            for (let key in localStorage) {
                data += "<tr><td>" + key + "</td><td>" + localStorage[key] + "</td>" +
                        "<td><a onclick=\"new emulator_storage().remove_object('" + key + 
                    "')\"" + ">Delete</a></td></tr>";
            }

            table.innerHTML = data;
        }
    }

    /** Remove the object corresponding to the given key */
    public remove_object (key: string) {
        localStorage.removeItem(key);
        emulator_storage.update_table();
    }

    /** Add/Set the given value/object to be stored at the given key. */
    public set_object (key: string, value: any): void {
        localStorage.setItem(key, JSON.stringify(value));
        emulator_storage.update_table();
    }

    /** Retrieve the object in local storage corresponding to the given key. */
    public get_object(key: string): any {
        let value = localStorage.getItem(key);
        return value && JSON.parse(value);
    }
}

/** Container Class for application information inside the emulator. This is 
 * generated by emulator.register_application, where the purposes are defined.
 */
class registered_application {
    constructor(public name: string, public start_callback: () => void,
                public render_callback: () => boolean, public home_callback: () => void) {
    }
}

/** Emulator user interface class. */
class emulator_ui {
    /// Applpications that are registered with the emulator
    public app_list: registered_application [];
    /// Index of currently displayed application
    private current_app: number;
    /// The canvas on which this UI is being drawn
    private canvas: HTMLCanvasElement;
    /// Even callback reference for removal, and readdition
    private gest_call_ref: gesture_callback_id;

    /** Construct this emulator ui */
    constructor() {
        this.current_app = 0;
        this.app_list = [];
    }

    /** Connect UI to a canvas for display */
    set_display (display: HTMLCanvasElement) {
        this.canvas = display;
    }

    /** Initialize the UI */
    init () {
        this.gest_call_ref = os.add_gesture_handler(
                (e: any, x: number, y: number) => this.gest_handle(e, x, y)
            ); // This anon function creates a closure so that `this` is a sensible value
        this.draw();
    }

    /** Draw the application name of the current application to screen */
    draw() {
        let ctx: CanvasRenderingContext2D = this.canvas.getContext("2d");
        ctx.clear();
        ctx.fillStyle = "#111111";
        ctx.fillRect(0, 0, ctx.width(), ctx.height());
        ctx.fillStyle = "#222222";
        let top_bar_height = 40;
        ctx.fillRect(0, 0, ctx.width(), top_bar_height);
        ctx.fillStyle = "#CCCCCC";
        let options = {
            weekday: "long", year: "numeric", month: "short",
            day: "numeric", hour: "2-digit", minute: "2-digit"
        };
        let time_display = os.get_time().toLocaleTimeString("en-GB", options);
        ctx.textAlign = "center";
        ctx.font = "15px sans-serif";
        ctx.fillText(time_display, this.canvas.width / 2, top_bar_height / 2);
        
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillStyle = "#EEEEEE";
        if (this.app_list[this.current_app]) {
            ctx.fillText(this.app_list[this.current_app].name, this.canvas.width / 2, this.canvas.height / 2);
        } else {
            ctx.fillText("No Application", this.canvas.width / 2, this.canvas.height / 2);
        }
    }


    /** Change the current application on swipe, and call the start callback 
     * when tapped.
     */
    gest_handle(evt: gesture_type, x: number, y: number) {
        if (this.app_list.length === 0) {
            return;
        }
        switch (evt) {
            // Go to next app
        case gesture_type.swipeleft:
            this.current_app = (this.current_app + 1) % this.app_list.length;
            this.draw();
            break;

            // Go to previous app
        case gesture_type.swiperight:
            this.current_app --;
            if (this.current_app < 0)
                this.current_app = this.app_list.length - 1;
            this.draw();
            break;

            // Start current app
        case gesture_type.tap:
            /*  First unregister UI click/swipe handlers */
            os.remove_gesture_handler(this.gest_call_ref);

            /* Call application to start, and then set set it to be rendered. */
            this.app_list[this.current_app].start_callback();
            let unsafe: any = os; // Remove type checking on the interface to access render_function directly
            unsafe.current_app = this.app_list[this.current_app];
        }
    }
}



/*
 * Main emulator API and internal logic.
 */

class emulator implements emulator {

    /** Emulator display canvas */
    private display: HTMLCanvasElement;
    /* Emulator UI instance */
    private ui: emulator_ui;
    /** List of gesture callbacks */
    private gesture_handlers: gesture_callback[];
    /** Gesture interpreter object - third party library */
    private gesture_interpreter: any;
    /** Current application to be rendered */
    current_app: registered_application;
    
    /** Last date that the get_time function was called */
    private last_date: Date;
    /** Last date that the get_time function returned */
    private last_reported_date: Date;

    /** Construct the smart watch */
    constructor() {
        this.gesture_handlers = [];
        this.ui = new emulator_ui();
        this.last_date = this.last_reported_date = new Date();
    }

    /** Initialize and start the smart watch */
    public init(canvas_id: string) {
        this.display = <HTMLCanvasElement> document.getElementById(canvas_id);

        this.ui.set_display(this.display);
        this.ui.init();

        this.gesture_interpreter = new Hammer(this.display, {preset: ["swipe", "tap"]});
        /* This wrapper lets us keep the `this` context correct to this object */
        let call_ref = ((e: any) => this.internal_gesture_reciever(e));
        /* Register to all the gestures we want */
        this.gesture_interpreter.on("tap", call_ref);
        this.gesture_interpreter.on("swipeup", call_ref);
        this.gesture_interpreter.on("swipedown", call_ref);
        this.gesture_interpreter.on("swipeleft", call_ref);
        this.gesture_interpreter.on("swiperight", call_ref);
        this.gesture_interpreter.get("swipe").set({ direction: Hammer.DIRECTION_ALL });

        this.current_app = undefined;

        // Make an initial call to set up render callbacks
        this.call_render();
    }

    /**
     * Get a CanvasRenderingContext2D which can draw on the display.
     * 
     * This is technically a browser object, but we have specified
     * the interface as part of the emulator, and also added some extensions.
     */
    public get_graphics_context(): graphics_context {
        return this.display.getContext("2d");
    }

    /**
     * This is the function responsible for getting the application
     * to draw a frame, by calling the application's render() function.
     * 
     * If the application's render function returns false, then control
     * is given back to the operating system.
     */
    private call_render(): void {
        // Make sure the emulator gets called on the next frame
        requestAnimationFrame(() => this.call_render());
        let result: boolean;

        // Tell the application to render
        if (this.current_app && this.current_app.render_callback) {
            result  = this.current_app.render_callback();

            // If the application says it no longer needs to render
            // i.e. is finished
            if (!result) {
                // Clear render function
                this.current_app = undefined;
                // Start back up UI
                this.ui.init();
            }
        } else {
            this.ui.draw();
        }
    }

    /**
     * Get the emulator's persistant storage.
     */
    public get_local_storage(): emulator_storage {
        return new emulator_storage();
    }

    /**
     * Add a handler for gestures. Uses the given callback in the context 
     * of the given object
     */    
    public add_gesture_handler(callback: gesture_callback): gesture_callback_id {
        return this.gesture_handlers.push(callback) - 1; 
    }

    /**
     * Remove/unset a handler for gestures. Must provide the returned value
     * from the corresponding call to add_gesture_handler
     *
     * This implementation has a slight memory leak, which is counter-balanced by
     * sparse arrays in ECMAscript.
     */    
    public remove_gesture_handler(callback_id: gesture_callback_id) {
        this.gesture_handlers[callback_id] = undefined;
        // TODO: this implementation could cause a memory leak
    }

    /**
     * Recieves gesture events from Hammer Library, then sends them through the
     * array of registered gesture event handlers.
     */
    private internal_gesture_reciever(ev: any) {
        // Translate mouse to internal coordinates
        let rect = this.display.getBoundingClientRect();
        ev.center.x = ev.center.x - rect.left;
        ev.center.y = ev.center.y - rect.top;
        switch (ev.type) {
        case "tap":
            this.gesture_handlers.forEach(function (item){
                if (item)
                    item(gesture_type.tap, ev.center.x, ev.center.y);
            });
            break;
        case "swipeup":
            this.gesture_handlers.forEach(function (item){
                if (item)
                    item(gesture_type.swipeup, ev.center.x, ev.center.y);
            });
            break;
        case "swipedown":
            this.gesture_handlers.forEach(function (item){
                if (item)
                    item(gesture_type.swipedown, ev.center.x, ev.center.y);
            });
            break;
        case "swipeleft":
            this.gesture_handlers.forEach(function (item){
                if (item)
                    item(gesture_type.swipeleft, ev.center.x, ev.center.y);
            });
            break;
        case "swiperight":
            this.gesture_handlers.forEach(function (item){
                if (item)
                    item(gesture_type.swiperight, ev.center.x, ev.center.y);
            });
            break;

        }
    }

    /**
     * Gets an image from the specified source for use with the grapics context.
     * @param src The source URL with respect to the root directory of the
     * emulator.
     */
    get_image(src: string): Image {
        let output = new Image();
        output.src = src;
        return output;
    }

    /**
     * Gets the current time in a Date object.
     */
    public get_time (): Date {
        let now = new Date();
        let time_scale: any = document.getElementById("time_scale");
        if (time_scale) {
            let diff = now.getTime() - this.last_date.getTime();
            diff *= Math.exp(time_scale.value / 10);
            let tmp = new Date();
            tmp.setTime(diff + this.last_reported_date.getTime());
            this.last_date = now;
            return this.last_reported_date = tmp;
        } else {
            return now;
        }
    }

    /**
     * Ask the emulator to close the current application.
     */
    public go_home (): void {
        if (this.current_app && this.current_app.home_callback)
            this.current_app.home_callback();
    }

    /**
     * Register an application with the emulator
     * 
     * @param start_callback will be called to initilize the application.
     * @param render_callback will be called to redraw/update the display periodically
     * (each frame). render_callback should return true if the application is to
     * continue, else control will be returned to the operating system. The
     * application can still reciever gesture notifications after returning false,
     * so these must be cleaned up first if this is not desired.
     * @param home_callback is called to request the application to stop,
     * allowing the return to the emulator. The application can choose if this
     * simply hides, or quits, but should not ignore.
     */
    public register_application (name: string, start_callback: () => void, render_callback: () => boolean, home_callback: () => void) {
        this.ui.app_list.push(new registered_application (name, start_callback, render_callback, home_callback));
    }

    /**
     * Log a message. This logs to the page element with
     * id="emulator_console", and to the browser console.
     */
    public log (log_text: string): void {
        console.log(log_text);
        let log_div = document.getElementById("emulator_console");
        if (log_div) {
            log_div.innerHTML += "<p>" + log_text + "</p>";
        }
    }
}




/** Make global emulator instance */
os  = new emulator();
